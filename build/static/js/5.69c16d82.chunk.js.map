{"version":3,"sources":["../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","../node_modules/react-shallow-equal/dist/react-shallow-equal.esm.js","../node_modules/react-text-mask-hoc/dist/react-text-mask-hoc.esm.js","../node_modules/style-equal/index.js"],"names":["REACT_STATICS","childContextTypes","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromProps","mixins","propTypes","type","KNOWN_STATICS","name","length","prototype","caller","callee","arguments","arity","defineProperty","Object","getOwnPropertyNames","getOwnPropertySymbols","getOwnPropertyDescriptor","getPrototypeOf","objectPrototype","module","exports","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","inheritedComponent","keys","concat","i","key","descriptor","e","_typeof","Symbol","iterator","obj","constructor","value","Array","isArray","propsEqual","a","b","options","undefined","aKeys","aCount","bCount","l","ignore","indexOf","bKeys","_i","_l","_key","style_equal_default","style","elementsEqual","typeOfA","ref","props","children","_extends","assign","target","source","hasOwnProperty","call","apply","this","_objectWithoutPropertiesLoose","excluded","sourceKeys","__webpack_require__","d","__webpack_exports__","react_text_mask_hoc_esm_TextMask","react_text_mask_hoc_esm_InputAdapter","defaultArray","emptyString","placeholderChar","strFunction","emptyArray","convertMaskToPlaceholder","mask","placeholderChar$$1","Error","JSON","stringify","map","char","RegExp","join","isString","String","strCaretTrap","processCaretTraps","indexOfCaretTrap","indexes","push","splice","maskWithoutCaretTraps","emptyArray$1","emptyString$1","getSafeRawValue","inputValue","isNaN","react_text_mask_hoc_esm_TextMaskTransformer","TextMaskTransformer","classCallCheck","previousConformedValue","previousPlaceholder","createClass","_ref2","placeholder","rawValue","currentCaretPosition","caretPosition","providedMask","guide","pipe","_ref2$placeholderChar","_ref2$keepCharPositio","keepCharPositions","_ref2$showMask","showMask","caretTrapIndexes","safeRawValue","_processCaretTraps","conformToMaskConfig","conformedValue","config","_config$guide","_config$previousConfo","_config$placeholderCh","_config$placeholder","suppressGuide","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","split","isNew","_i4","someCharsRejected","placeholderLoop","_i5","charInPlaceholder","_rawValueArr$shift","shift","rawValueChar","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","_i6","charData","substr","indexOfLastFilledPlaceholderChar","_i7","meta","conformToMask","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","_ref","_ref$previousConforme","_ref$previousPlacehol","_ref$currentCaretPosi","_ref$indexesOfPipedCh","indexesOfPipedChars","_ref$caretTrapIndexes","conformedValueLength","editLength","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue","toLowerCase","intersection","filter","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","countTargetCharInPipedChars","index","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","_i2","_i3","adjustCaretPosition","inputElementValue","_React$PureComponent","TextMask","context","_this","possibleConstructorReturn","_update","bind","assertThisInitialized","_getRef","_onChange","component","textMaskTransformer","nextUpdate","state","inherits","nextProps","isControlled","setState","update","comp","componentRef","event","_this2","text","onChange","forceUpdate","input","focus","blur","_this$props","Component","rest","react_default","createElement","get","PureComponent","isAndroid","navigator","userAgent","isDocument","document","_React$PureComponent2","InputAdapter","_this3","_setCaretPosition","persist","_this4","activeElement","setTimeout","setSelectionRange","selectionEnd","transformEntryEqual","k","transformEqual","styleEqual","shallowObjectEquals","j"],"mappings":"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","file":"static/js/5.69c16d82.chunk.js","sourcesContent":["'use strict';\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\nvar REACT_STATICS = {\n  childContextTypes: true,\n  contextTypes: true,\n  defaultProps: true,\n  displayName: true,\n  getDefaultProps: true,\n  getDerivedStateFromProps: true,\n  mixins: true,\n  propTypes: true,\n  type: true\n};\nvar KNOWN_STATICS = {\n  name: true,\n  length: true,\n  prototype: true,\n  caller: true,\n  callee: true,\n  arguments: true,\n  arity: true\n};\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n  if (typeof sourceComponent !== 'string') {\n    // don't hoist over string (html) components\n    if (objectPrototype) {\n      var inheritedComponent = getPrototypeOf(sourceComponent);\n\n      if (inheritedComponent && inheritedComponent !== objectPrototype) {\n        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n      }\n    }\n\n    var keys = getOwnPropertyNames(sourceComponent);\n\n    if (getOwnPropertySymbols) {\n      keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n    }\n\n    for (var i = 0; i < keys.length; ++i) {\n      var key = keys[i];\n\n      if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\n        try {\n          // Avoid failures from read-only properties\n          defineProperty(targetComponent, key, descriptor);\n        } catch (e) {}\n      }\n    }\n\n    return targetComponent;\n  }\n\n  return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;","import stylesEqual from 'style-equal';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* eslint-disable import/prefer-default-export */\n\n\nfunction type(value) {\n  if (value === null) return 'null';\n  if (Array.isArray(value)) return 'array';\n  return typeof value === 'undefined' ? 'undefined' : _typeof(value);\n}\n\nfunction elementsEqual(a, b) {\n  var typeOfA = type(a);\n  if (typeOfA !== type(b)) return false;\n\n  switch (typeOfA) {\n    case 'array':\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (!elementsEqual(a[i], b[i])) return false;\n      }\n\n      return true;\n\n    case 'object':\n      if (a.type !== b.type) return false;\n      if (a.key !== b.key) return false;\n      if (a.ref !== b.ref) return false;\n      return propsEqual(a.props, b.props);\n    // eslint-disable-line no-use-before-define\n\n    default:\n      return a === b;\n  }\n}\n\nfunction propsEqual(a, b) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var aKeys = Object.keys(a);\n  var aCount = 0;\n  var bCount = 0;\n\n  for (var i = 0, l = aKeys.length; i < l; i++) {\n    var key = aKeys[i];\n\n    if (!options.ignore || options.ignore.indexOf(key) === -1) {\n      // Compare `style` and `children` props later\n      if (key !== 'style' && key !== 'children' && a[key] !== b[key]) return false;\n      aCount += 1;\n    }\n  }\n\n  var bKeys = Object.keys(b);\n\n  for (var _i = 0, _l = bKeys.length; _i < _l; _i++) {\n    var _key = bKeys[_i];\n\n    if (!options.ignore || options.ignore.indexOf(_key) === -1) {\n      bCount += 1;\n    }\n  }\n\n  if (aCount !== bCount) return false; // NOTE: Kind of risky, but I'm assuming that a `style` prop is a React Native style,\n  // and using the `styleEqual` algorithm here.\n\n  if (!stylesEqual(a.style, b.style)) return false; // Compare children last\n\n  return elementsEqual(a.children, b.children);\n}\n\nexport { stylesEqual, propsEqual, elementsEqual };","import _possibleConstructorReturn from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/jeremynelson/code/test3/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport React from 'react';\nimport { propsEqual } from 'react-shallow-equal';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar defaultArray = [];\nvar emptyString = '';\n\nfunction adjustCaretPosition(_ref) {\n  var _ref$previousConforme = _ref.previousConformedValue,\n      previousConformedValue = _ref$previousConforme === void 0 ? emptyString : _ref$previousConforme,\n      _ref$previousPlacehol = _ref.previousPlaceholder,\n      previousPlaceholder = _ref$previousPlacehol === void 0 ? emptyString : _ref$previousPlacehol,\n      _ref$currentCaretPosi = _ref.currentCaretPosition,\n      currentCaretPosition = _ref$currentCaretPosi === void 0 ? 0 : _ref$currentCaretPosi,\n      conformedValue = _ref.conformedValue,\n      rawValue = _ref.rawValue,\n      placeholderChar = _ref.placeholderChar,\n      placeholder = _ref.placeholder,\n      _ref$indexesOfPipedCh = _ref.indexesOfPipedChars,\n      indexesOfPipedChars = _ref$indexesOfPipedCh === void 0 ? defaultArray : _ref$indexesOfPipedCh,\n      _ref$caretTrapIndexes = _ref.caretTrapIndexes,\n      caretTrapIndexes = _ref$caretTrapIndexes === void 0 ? defaultArray : _ref$caretTrapIndexes;\n\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  } // Store lengths for faster performance?\n\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var conformedValueLength = conformedValue.length; // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n\n  var editLength = rawValueLength - previousConformedValueLength; // If the edit length is positive, that means the user is adding characters, not deleting.\n\n  var isAddition = editLength > 0; // This is the first raw value the user entered that needs to be conformed to mask\n\n  var isFirstRawValue = previousConformedValueLength === 0; // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n\n  var isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue; // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  } // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n\n\n  var possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n  var startingSearchIndex = 0;\n  var trackRightCharacter;\n  var targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    var normalizedConformedValue = conformedValue.toLowerCase();\n    var normalizedRawValue = rawValue.toLowerCase(); // Then we take all characters that come before where the caret currently is.\n\n    var leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString); // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n\n    var intersection = leftHalfChars.filter(function (char) {\n      return normalizedConformedValue.indexOf(char) !== -1;\n    }); // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n\n    targetChar = intersection[intersection.length - 1]; // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n\n    var previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n\n    var leftMaskChars = placeholder.substr(0, intersection.length).split(emptyString).filter(function (char) {\n      return char !== placeholderChar;\n    }).length; // Has the number of mask characters up to the caret changed?\n\n    var masklengthChanged = leftMaskChars !== previousLeftMaskChars; // Detect if `targetChar` is a mask character and has moved to the left\n\n    var targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]; // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n\n    if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    } // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n\n\n    var pipedChars = indexesOfPipedChars.map(function (index) {\n      return normalizedConformedValue[index];\n    }); // We need to know how many times the `targetChar` occurs in the piped characters.\n\n    var countTargetCharInPipedChars = pipedChars.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know how many times it occurs in the intersection\n\n    var countTargetCharInIntersection = intersection.filter(function (char) {\n      return char === targetChar;\n    }).length; // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n\n    var countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split(emptyString).filter(function (char, index) {\n      return (// Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar && // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      );\n    }).length; // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n\n    var requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + ( // The character to the right of the caret isn't included in `intersection`\n    // so add one if we are tracking the character to the right\n    trackRightCharacter ? 1 : 0); // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n\n    var numberOfEncounteredMatches = 0;\n\n    for (var i = 0; i < conformedValueLength; i++) {\n      var conformedValueChar = normalizedConformedValue[i];\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  } // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n  // In case of addition, we fast forward.\n\n\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    var lastPlaceholderChar = startingSearchIndex;\n\n    for (var _i = startingSearchIndex; _i <= placeholderLength; _i++) {\n      if (placeholder[_i] === placeholderChar) {\n        lastPlaceholderChar = _i;\n      }\n\n      if ( // If we're adding, we can position the caret at the next placeholder character.\n      placeholder[_i] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n      caretTrapIndexes.indexOf(_i) !== -1 || // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n      _i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (var _i2 = startingSearchIndex - 1; _i2 >= 0; _i2--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n        if ( // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n        // to the right of the caret\n        conformedValue[_i2] === targetChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i2) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i2 === 0) {\n          return _i2;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (var _i3 = startingSearchIndex; _i3 >= 0; _i3--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n        if ( // If we're deleting, we can position the caret right before the placeholder character\n        placeholder[_i3 - 1] === placeholderChar || // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(_i3) !== -1 || // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        _i3 === 0) {\n          return _i3;\n        }\n      }\n    }\n  }\n}\n\nvar placeholderChar = '_';\nvar strFunction = 'function';\nvar emptyArray = [];\n\nfunction convertMaskToPlaceholder() {\n  var mask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyArray;\n  var placeholderChar$$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : placeholderChar;\n\n  if (!isArray(mask)) {\n    throw new Error('Text-mask:convertMaskToPlaceholder; The mask property must be an array.');\n  }\n\n  if (mask.indexOf(placeholderChar$$1) !== -1) {\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + \"The placeholder character that was received is: \".concat(JSON.stringify(placeholderChar$$1), \"\\n\\n\") + \"The mask that was received is: \".concat(JSON.stringify(mask)));\n  }\n\n  return mask.map(function (char) {\n    return char instanceof RegExp ? placeholderChar$$1 : char;\n  }).join('');\n}\n\nfunction isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\n\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value);\n}\n\nvar strCaretTrap = '[]';\n\nfunction processCaretTraps(mask) {\n  var indexes = [];\n  var indexOfCaretTrap;\n\n  while (indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) {\n    // eslint-disable-line\n    indexes.push(indexOfCaretTrap);\n    mask.splice(indexOfCaretTrap, 1);\n  }\n\n  return {\n    maskWithoutCaretTraps: mask,\n    indexes: indexes\n  };\n}\n\nvar emptyArray$1 = [];\nvar emptyString$1 = '';\n\nfunction conformToMask() {\n  var rawValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyString$1;\n  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : emptyArray$1;\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === strFunction) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config); // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error('Text-mask:conformToMask; The mask property must be an array.');\n    }\n  } // These configurations tell us how to conform the mask\n\n\n  var _config$guide = config.guide,\n      guide = _config$guide === void 0 ? true : _config$guide,\n      _config$previousConfo = config.previousConformedValue,\n      previousConformedValue = _config$previousConfo === void 0 ? emptyString$1 : _config$previousConfo,\n      _config$placeholderCh = config.placeholderChar,\n      placeholderChar$$1 = _config$placeholderCh === void 0 ? placeholderChar : _config$placeholderCh,\n      _config$placeholder = config.placeholder,\n      placeholder = _config$placeholder === void 0 ? convertMaskToPlaceholder(mask, placeholderChar$$1) : _config$placeholder,\n      currentCaretPosition = config.currentCaretPosition,\n      keepCharPositions = config.keepCharPositions; // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n\n  var suppressGuide = guide === false && previousConformedValue !== undefined; // Calculate lengths once for performance\n\n  var rawValueLength = rawValue.length;\n  var previousConformedValueLength = previousConformedValue.length;\n  var placeholderLength = placeholder.length;\n  var maskLength = mask.length; // This tells us the number of edited characters and the direction in which they were edited (+/-)\n\n  var editDistance = rawValueLength - previousConformedValueLength; // In *no guide* mode, we need to know if the user is trying to add a character or not\n\n  var isAddition = editDistance > 0; // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n\n  var indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0); // We're also gonna need the index of last change, which we can derive as follows...\n\n  var indexOfLastChange = indexOfFirstChange + Math.abs(editDistance); // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    var compensatingPlaceholderChars = emptyString$1; // For every character that was deleted from a placeholder position, we add a placeholder char\n\n    for (var i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar$$1) {\n        compensatingPlaceholderChars += placeholderChar$$1;\n      }\n    } // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n\n\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  } // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n\n\n  var rawValueArr = rawValue.split(emptyString$1).map(function (char, i) {\n    return {\n      char: char,\n      isNew: i >= indexOfFirstChange && i < indexOfLastChange\n    };\n  }); // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n\n  for (var _i4 = rawValueLength - 1; _i4 >= 0; _i4--) {\n    var char = rawValueArr[_i4].char;\n\n    if (char !== placeholderChar$$1) {\n      var shouldOffset = _i4 >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? _i4 - editDistance : _i4]) {\n        rawValueArr.splice(_i4, 1);\n      }\n    }\n  } // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n\n\n  var conformedValue = emptyString$1;\n  var someCharsRejected = false; // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n\n  placeholderLoop: for (var _i5 = 0; _i5 < placeholderLength; _i5++) {\n    var charInPlaceholder = placeholder[_i5]; // We see one. Let's find out what we can put in it.\n\n    if (charInPlaceholder === placeholderChar$$1) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          var _rawValueArr$shift = rawValueArr.shift(),\n              rawValueChar = _rawValueArr$shift.char,\n              isNew = _rawValueArr$shift.isNew; // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n\n\n          if (rawValueChar === placeholderChar$$1 && suppressGuide !== true) {\n            conformedValue += placeholderChar$$1; // And we go to find the next placeholder character that needs filling\n\n            continue placeholderLoop; // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[_i5].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || isNew === false || previousConformedValue === emptyString$1 || guide === false || !isAddition) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              var rawValueArrLength = rawValueArr.length;\n              var indexOfNextAvailablePlaceholderChar = null; // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n\n              for (var _i6 = 0; _i6 < rawValueArrLength; _i6++) {\n                var charData = rawValueArr[_i6];\n\n                if (charData.char !== placeholderChar$$1 && charData.isNew === false) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar$$1) {\n                  indexOfNextAvailablePlaceholderChar = _i6;\n                  break;\n                }\n              } // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n\n\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1); // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                _i5--;\n              }\n            } // Since we've mapped this placeholder position. We move on to the next one.\n\n\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      } // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n\n\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(_i5, placeholderLength);\n      } // And we break\n\n\n      break; // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  } // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n\n\n  if (suppressGuide && isAddition === false) {\n    var indexOfLastFilledPlaceholderChar = null; // Find the last filled placeholder position and substring from there\n\n    for (var _i7 = 0; _i7 < conformedValue.length; _i7++) {\n      if (placeholder[_i7] === placeholderChar$$1) {\n        indexOfLastFilledPlaceholderChar = _i7;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString$1;\n    }\n  }\n\n  return {\n    conformedValue: conformedValue,\n    meta: {\n      someCharsRejected: someCharsRejected\n    }\n  };\n}\n\nfunction getSafeRawValue(inputValue) {\n  if (inputValue == null) return '';\n  if (isString(inputValue)) return inputValue;\n  if (isNumber(inputValue)) return String(inputValue);\n  throw new Error(\"The 'value' provided to Text Mask needs to be a string or a number. The value \" + \"received was:\\n\\n \".concat(JSON.stringify(inputValue)));\n}\n\nvar TextMaskTransformer =\n/*#__PURE__*/\nfunction () {\n  function TextMaskTransformer() {\n    _classCallCheck(this, TextMaskTransformer);\n\n    this.previousConformedValue = undefined;\n    this.previousPlaceholder = undefined;\n  }\n\n  _createClass(TextMaskTransformer, [{\n    key: \"update\",\n    value: function update(_ref2) {\n      var rawValue = _ref2.value,\n          currentCaretPosition = _ref2.caretPosition,\n          providedMask = _ref2.mask,\n          guide = _ref2.guide,\n          pipe = _ref2.pipe,\n          _ref2$placeholderChar = _ref2.placeholderChar,\n          placeholderChar$$1 = _ref2$placeholderChar === void 0 ? placeholderChar : _ref2$placeholderChar,\n          _ref2$keepCharPositio = _ref2.keepCharPositions,\n          keepCharPositions = _ref2$keepCharPositio === void 0 ? false : _ref2$keepCharPositio,\n          _ref2$showMask = _ref2.showMask,\n          showMask = _ref2$showMask === void 0 ? false : _ref2$showMask;\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === this.previousConformedValue) {\n        return null;\n      } // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n      // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n      // as if a separate `mask` and a `pipe` were passed.\n\n\n      if (providedMask != null && typeof providedMask === 'object' && providedMask.pipe != null && providedMask.mask != null) {\n        /* eslint-disable no-param-reassign, prefer-destructuring */\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n        /* eslint-enable */\n      } // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n      // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n\n\n      var placeholder; // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n      // we will have to call that function to get the mask array.\n\n      var mask; // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n\n      if (Array.isArray(providedMask)) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar$$1);\n      } // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n\n\n      var safeRawValue = getSafeRawValue(rawValue); // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n\n      if (providedMask === false) {\n        return {\n          value: safeRawValue,\n          caretPosition: currentCaretPosition\n        };\n      }\n\n      var caretTrapIndexes; // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition: currentCaretPosition,\n          previousConformedValue: this.previousConformedValue,\n          placeholderChar: placeholderChar$$1\n        }); // disable masking if `mask` is `false`\n\n        if (mask === false) {\n          return null;\n        } // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n\n\n        var _processCaretTraps = processCaretTraps(mask),\n            maskWithoutCaretTraps = _processCaretTraps.maskWithoutCaretTraps,\n            indexes = _processCaretTraps.indexes; // The processed mask is what we're interested in\n\n\n        mask = maskWithoutCaretTraps; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        caretTrapIndexes = indexes;\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar$$1); // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      } // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n\n\n      var conformToMaskConfig = {\n        previousConformedValue: this.previousConformedValue,\n        guide: guide,\n        placeholderChar: placeholderChar$$1,\n        pipe: pipe,\n        placeholder: placeholder,\n        currentCaretPosition: currentCaretPosition,\n        keepCharPositions: keepCharPositions\n      }; // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n\n      var _conformToMask = conformToMask(safeRawValue, mask, conformToMaskConfig),\n          conformedValue = _conformToMask.conformedValue; // The following few lines are to support the `pipe` feature.\n\n\n      var piped = typeof pipe === 'function';\n      var pipeResults = {}; // If `pipe` is a function, we call it.\n\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, _extends({\n          rawValue: safeRawValue\n        }, conformToMaskConfig)); // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n        // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n          // and set `rejected` to `true`.\n          pipeResults = {\n            value: this.previousConformedValue,\n            rejected: true\n          };\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n        }\n      } // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n\n\n      var finalConformedValue = piped ? pipeResults.value : conformedValue; // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n\n      var adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue: this.previousConformedValue,\n        previousPlaceholder: this.previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder: placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition,\n        placeholderChar: placeholderChar$$1,\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n        caretTrapIndexes: caretTrapIndexes\n      }); // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n\n      var inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      var emptyValue = showMask ? placeholder : '';\n      var inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      this.previousConformedValue = inputElementValue; // store value for access for next time\n\n      this.previousPlaceholder = placeholder;\n      return {\n        value: inputElementValue,\n        caretPosition: adjustedCaretPosition\n      };\n    }\n  }]);\n\n  return TextMaskTransformer;\n}();\n\nvar TextMask =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(TextMask, _React$PureComponent);\n\n  function TextMask(props, context) {\n    var _this;\n\n    _classCallCheck(this, TextMask);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextMask).call(this, props, context));\n    _this._update = _this._update.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._getRef = _this._getRef.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this._onChange = _this._onChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.component = null;\n    _this.textMaskTransformer = new TextMaskTransformer();\n    var value = props.value != null ? props.value : '';\n\n    var nextUpdate = _this._update(_extends({}, props, {\n      value: value\n    }));\n\n    if (nextUpdate !== null) {\n      _this.state = {\n        value: nextUpdate.value,\n        caretPosition: nextUpdate.caretPosition\n      };\n    } else {\n      _this.state = {\n        value: '',\n        caretPosition: 0\n      };\n    }\n\n    return _this;\n  }\n\n  _createClass(TextMask, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var ignore = [];\n\n      if (nextProps.isControlled === false) {\n        ignore.push('value');\n      }\n\n      if (!propsEqual(this.props, nextProps, {\n        ignore: ignore\n      })) {\n        var value = nextProps.isControlled === true && nextProps.value != null ? nextProps.value : this.state.value;\n\n        var nextUpdate = this._update(_extends({}, nextProps, {\n          value: value\n        }));\n\n        if (nextUpdate !== null) {\n          this.setState(nextUpdate);\n        }\n      }\n    }\n  }, {\n    key: \"_update\",\n    value: function _update(props) {\n      return this.textMaskTransformer.update({\n        value: props.value,\n        caretPosition: this.component != null ? this.component.caretPosition : 0,\n        mask: props.mask,\n        guide: props.guide,\n        pipe: props.pipe,\n        placeholderChar: props.placeholderChar,\n        keepCharPositions: props.keepCharPositions,\n        showMask: props.showMask\n      });\n    }\n  }, {\n    key: \"_getRef\",\n    value: function _getRef(comp) {\n      if (comp) {\n        this.props.componentRef(comp);\n        this.component = comp;\n      }\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(event) {\n      var _this2 = this;\n\n      if (event) {\n        var rawValue = typeof event.target === 'object' ? event.target.value : event.text;\n\n        var nextUpdate = this._update(_extends({}, this.props, {\n          value: rawValue\n        }));\n\n        if (nextUpdate !== null) {\n          this.setState(nextUpdate, function () {\n            _this2.props.onChange(event, nextUpdate);\n          });\n        } else {\n          this.props.onChange(event, this.state);\n          this.forceUpdate();\n        }\n      }\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.component.input) this.component.input.focus();\n    }\n  }, {\n    key: \"blur\",\n    value: function blur() {\n      if (this.component.input) this.component.input.blur();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          Component = _this$props.Component,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"Component\", \"value\", \"isControlled\", \"mask\", \"guide\", \"pipe\", \"placeholderChar\", \"keepCharPositions\", \"showMask\", \"componentRef\", \"onChange\"]);\n\n      return React.createElement(Component, _extends({}, rest, {\n        value: this.state.value,\n        caretPosition: this.state.caretPosition,\n        onChange: this._onChange,\n        ref: this._getRef\n      }));\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.state.value;\n    }\n  }]);\n\n  return TextMask;\n}(React.PureComponent);\n\nTextMask.defaultProps = {\n  value: null,\n  isControlled: true,\n  guide: true,\n  pipe: null,\n  placeholderChar: '_',\n  keepCharPositions: false,\n  showMask: false,\n  onChange: function onChange() {},\n  componentRef: function componentRef() {}\n};\nvar isAndroid = typeof navigator !== 'undefined' && navigator !== null && /android/i.test(navigator.userAgent);\nvar isDocument = typeof document !== 'undefined' && document !== null;\n\nvar InputAdapter =\n/*#__PURE__*/\nfunction (_React$PureComponent2) {\n  _inherits(InputAdapter, _React$PureComponent2);\n\n  function InputAdapter(props) {\n    var _this3;\n\n    _classCallCheck(this, InputAdapter);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(InputAdapter).call(this, props));\n    _this3._getRef = _this3._getRef.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\n    _this3._onChange = _this3._onChange.bind(_assertThisInitialized(_assertThisInitialized(_this3)));\n    return _this3;\n  }\n\n  _createClass(InputAdapter, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._setCaretPosition();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this._setCaretPosition();\n    }\n  }, {\n    key: \"_getRef\",\n    value: function _getRef(ref) {\n      this.input = ref;\n    }\n  }, {\n    key: \"_onChange\",\n    value: function _onChange(event) {\n      event.persist();\n      this.props.onChange(event);\n    }\n  }, {\n    key: \"_setCaretPosition\",\n    value: function _setCaretPosition() {\n      var _this4 = this;\n\n      if (isDocument && this.input === document.activeElement) {\n        if (isAndroid === true) {\n          setTimeout(function () {\n            _this4.input.setSelectionRange(_this4.props.caretPosition, _this4.props.caretPosition, 'none');\n          }, 0);\n        } else {\n          this.input.setSelectionRange(this.props.caretPosition, this.props.caretPosition, 'none');\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"caretPosition\", \"onChange\"]);\n\n      return React.createElement(\"input\", _extends({\n        ref: this._getRef,\n        type: \"text\",\n        onChange: this._onChange\n      }, rest));\n    }\n  }, {\n    key: \"caretPosition\",\n    get: function get() {\n      return this.input.selectionEnd;\n    }\n  }]);\n\n  return InputAdapter;\n}(React.PureComponent);\n\nvar SpanAdapter =\n/*#__PURE__*/\nfunction (_React$PureComponent3) {\n  _inherits(SpanAdapter, _React$PureComponent3);\n\n  function SpanAdapter() {\n    _classCallCheck(this, SpanAdapter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpanAdapter).apply(this, arguments));\n  }\n\n  _createClass(SpanAdapter, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          value = _this$props.value,\n          rest = _objectWithoutPropertiesLoose(_this$props, [\"value\", \"caretPosition\", \"onChange\"]);\n\n      return React.createElement(\"span\", rest, value);\n    }\n  }, {\n    key: \"caretPosition\",\n    // eslint-disable-next-line class-methods-use-this\n    get: function get() {\n      return 0;\n    }\n  }]);\n\n  return SpanAdapter;\n}(React.PureComponent);\n\nexport { TextMask, InputAdapter, SpanAdapter, TextMaskTransformer };","var hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction transformEntryEqual(a, b) {\n  for (var k in a) {\n    if (hasOwnProperty.call(a, k)) {\n      return a[k] === b[k];\n    }\n  }\n\n  return false;\n}\n\nfunction transformEqual(a, b) {\n  if (!a && !b || a === b) {\n    return true;\n  }\n\n  if (!a !== !b) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    if (!transformEntryEqual(a[i], b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction shallowObjectEquals(a, b) {\n  var k;\n  var i = 0;\n  var j = 0;\n\n  for (k in a) {\n    if (hasOwnProperty.call(a, k)) {\n      switch (k) {\n        case 'transform':\n          if (!transformEqual(a[k], b[k])) {\n            return false;\n          }\n\n          break;\n\n        case 'shadowOffset':\n          if (!shallowObjectEquals(a[k], b[k])) {\n            return false;\n          }\n\n          break;\n\n        default:\n          if (a[k] !== b[k]) {\n            return false;\n          }\n\n          break;\n      }\n\n      i++;\n    }\n  }\n\n  for (k in b) {\n    if (hasOwnProperty.call(b, k)) {\n      j++;\n    }\n  }\n\n  return i === j;\n}\n\nfunction styleEqual(a, b) {\n  if (!a && !b || a === b) {\n    return true;\n  }\n\n  if (!a !== !b) {\n    return false;\n  }\n\n  switch (typeof a) {\n    case 'object':\n      if (a instanceof Array) {\n        for (var i = 0; i < a.length; i++) {\n          if (!styleEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n\n        return a.length === b.length;\n      } else {\n        return shallowObjectEquals(a, b);\n      }\n\n      break;\n\n    case 'number':\n    default:\n      return a === b;\n  }\n}\n\nmodule.exports = styleEqual;"],"sourceRoot":""}